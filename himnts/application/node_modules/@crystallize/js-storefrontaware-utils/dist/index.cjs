"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createFilesystemAdapter: () => createFilesystemAdapter,
  createMemoryAdapter: () => createMemoryAdapter,
  createStoreFront: () => createStoreFront,
  createSuperFastAdapter: () => createSuperFastAdapter,
  cypher: () => cypher,
  decryptValue: () => decryptValue,
  encryptValue: () => encryptValue,
  fetchSuperFastConfigWithClient: () => fetchSuperFastConfigWithClient,
  mapToStoreConfig: () => mapToStoreConfig,
  superFastTenantQueryConfig: () => superFastTenantQueryConfig
});
module.exports = __toCommonJS(src_exports);

// src/cypher.ts
var import_crypto = __toESM(require("crypto"), 1);
function encryptValue(value, secretKey, algorithm) {
  const initVector = import_crypto.default.randomBytes(16);
  const cipher = import_crypto.default.createCipheriv(algorithm, secretKey, initVector);
  let encryptedData = cipher.update(value, "utf-8", "hex");
  encryptedData += cipher.final("hex");
  return `${initVector.toString("hex")}:${encryptedData}`;
}
function decryptValue(value, secretKey, algorithm) {
  if (value?.includes(":")) {
    const [initVector, encryptedData] = value.split(":");
    const decipher = import_crypto.default.createDecipheriv(algorithm, secretKey, Buffer.from(initVector, "hex"));
    let decryptedData = decipher.update(encryptedData, "hex", "utf-8");
    decryptedData += decipher.final("utf8");
    return decryptedData;
  }
  return value || "";
}
var cypher = (secret) => {
  const key = import_crypto.default.createHash("sha256").update(String(secret)).digest("base64").substring(0, 32);
  const algorithm = "aes-256-cbc";
  const encrypt = (value) => encryptValue(value, key, algorithm);
  const decrypt = (value) => decryptValue(value, key, algorithm);
  return {
    encrypt,
    decrypt,
    decryptMap: (map) => {
      let result = {};
      Object.keys(map).forEach((key2) => {
        result = {
          ...result,
          [key2]: decrypt(map[key2])
        };
      });
      return result;
    }
  };
};

// src/adapters/filesystem.server.ts
var import_promises = __toESM(require("fs/promises"), 1);
var createFilesystemAdapter = (filename) => {
  return {
    config: async (withSecrets) => {
      const data = await import_promises.default.readFile(filename, { encoding: "utf8" });
      const unfilteredSecrets = JSON.parse(data);
      if (withSecrets) {
        return unfilteredSecrets;
      }
      return {
        ...unfilteredSecrets,
        configuration: {
          ...unfilteredSecrets.configuration,
          CRYSTALLIZE_ACCESS_TOKEN_ID: "",
          CRYSTALLIZE_ACCESS_TOKEN_SECRET: ""
        }
      };
    }
  };
};

// src/adapters/memory.server.ts
var createMemoryAdapter = (config) => {
  return {
    config: async (withSecrets) => {
      if (withSecrets) {
        return config;
      }
      return {
        ...config,
        configuration: {
          ...config.configuration,
          CRYSTALLIZE_ACCESS_TOKEN_ID: "",
          CRYSTALLIZE_ACCESS_TOKEN_SECRET: ""
        }
      };
    }
  };
};

// src/adapters/superfast.server.ts
var import_js_api_client = require("@crystallize/js-api-client");
var import_json_to_graphql_query = require("json-to-graphql-query");
var getExpiry = (ttl) => Math.floor(Date.now() / 1e3) + ttl;
var createSuperFastAdapter = (hostname, credentials, storageClient, ttl) => {
  const memoryCache = {};
  const { decrypt, decryptMap } = cypher(process.env.ENCRYPTED_PARAMS_SECRET);
  async function config(withSecrets = false) {
    const domainkey = hostname.split(".")[0];
    if (memoryCache[domainkey]) {
      if (memoryCache[domainkey].expiresAt > Date.now() / 1e3) {
        return memoryCache[domainkey].value;
      }
    }
    const hit = await storageClient.get(domainkey);
    let config2 = void 0;
    if (!hit) {
      config2 = await fetchSuperFastConfig(`/tenants/${domainkey}`, credentials);
      await storageClient.set(domainkey, JSON.stringify(config2), ttl);
    } else {
      config2 = JSON.parse(hit);
    }
    if (config2 !== void 0) {
      memoryCache[domainkey] = {
        expiresAt: getExpiry(ttl),
        value: config2
      };
      if (withSecrets) {
        config2.configuration = decryptMap(config2.configuration);
      } else {
        config2.configuration = {
          ...config2.configuration,
          STRIPE_PUBLIC_KEY: decrypt(config2.configuration.STRIPE_PUBLIC_KEY),
          RAZORPAY_ID: decrypt(config2.configuration.RAZORPAY_ID),
          ADYEN_ENV: decrypt(config2.configuration.ADYEN_ENV),
          ADYEN_MERCHANT_ACCOUNT: decrypt(config2.configuration.ADYEN_MERCHANT_ACCOUNT),
          ADYEN_CLIENT_KEY: decrypt(config2.configuration.ADYEN_CLIENT_KEY)
        };
      }
      return config2;
    }
    throw new Error("Impossible to fetch SuperFast config");
  }
  return { config };
};
var superFastTenantQueryConfig = {
  id: true,
  name: true,
  path: true,
  components: {
    id: true,
    content: {
      __typename: true,
      __on: [
        {
          __typeName: "SingleLineContent",
          text: true
        },
        {
          __typeName: "RichTextContent",
          html: true
        },
        {
          __typeName: "SelectionContent",
          options: {
            key: true,
            value: true
          }
        },
        {
          __typeName: "BooleanContent",
          value: true
        },
        {
          __typeName: "ImageContent",
          firstImage: {
            url: true,
            key: true,
            variants: {
              key: true,
              url: true,
              width: true,
              height: true
            }
          }
        },
        {
          __typeName: "PropertiesTableContent",
          sections: {
            title: true,
            properties: {
              key: true,
              value: true
            }
          }
        }
      ]
    }
  }
};
function componentToString(component) {
  switch (component?.content?.__typename) {
    case "SingleLineContent":
      return component.content.text;
    case "RichTextContent":
      return component.content.html.join("");
    case "SelectionContent":
      return component.content.options.map((option) => option.key);
    case "BooleanContent":
      return component.content.value;
    case "ImageContent":
      return component.content.firstImage;
    case "PropertiesTableContent":
      return component.content.sections.reduce((result, section) => {
        section.properties.forEach((property) => {
          result[`${section.title.toUpperCase()}_${property.key.toUpperCase()}`] = `${property.value}`;
        });
        return result;
      }, {});
    default:
      return false;
  }
}
function mapToStoreConfig(data) {
  const components = data.components.reduce((result, component) => {
    return {
      ...result,
      [component.id]: componentToString(component)
    };
  }, {});
  return {
    id: data.id,
    name: data.name,
    identifier: data.path.replace("/tenants/", ""),
    tenantIdentifier: components["tenant-identifier"],
    tenantId: components["tenant-id"] || void 0,
    language: "en",
    storefront: components.storefront,
    logo: components.logos,
    theme: components.theme[0],
    configuration: components.configuration,
    superfastVersion: components["superfast-version"],
    enabled: components["enabled"],
    paymentMethods: components["payment-methods"],
    taxIncluded: components["taxincluded"]
  };
}
async function fetchSuperFastConfigWithClient(path, client) {
  const query = {
    catalogue: {
      __args: {
        path
      },
      ...superFastTenantQueryConfig
    }
  };
  const tenant = await client.catalogueApi((0, import_json_to_graphql_query.jsonToGraphQLQuery)({ query }));
  return mapToStoreConfig({
    id: tenant.catalogue.id,
    name: tenant.catalogue.name,
    path,
    components: tenant.catalogue.components
  });
}
async function fetchSuperFastConfig(path, credentials) {
  const client = (0, import_js_api_client.createClient)(credentials);
  return fetchSuperFastConfigWithClient(path, client);
}

// src/storefront.server.ts
var import_js_api_client2 = require("@crystallize/js-api-client");
var createStoreFront = async (adapter, options = false, clientOptions) => {
  options = typeof options === "boolean" ? { withSecrets: options } : options;
  const withSecrets = options?.withSecrets ?? false;
  const config = await adapter.config(withSecrets);
  return {
    config,
    apiClient: (0, import_js_api_client2.createClient)(
      {
        tenantIdentifier: config.tenantIdentifier,
        tenantId: config.tenantId,
        accessTokenId: withSecrets ? config.configuration?.CRYSTALLIZE_ACCESS_TOKEN_ID || "" : "",
        accessTokenSecret: withSecrets ? config.configuration?.CRYSTALLIZE_ACCESS_TOKEN_SECRET || "" : ""
      },
      clientOptions
    )
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createFilesystemAdapter,
  createMemoryAdapter,
  createStoreFront,
  createSuperFastAdapter,
  cypher,
  decryptValue,
  encryptValue,
  fetchSuperFastConfigWithClient,
  mapToStoreConfig,
  superFastTenantQueryConfig
});
