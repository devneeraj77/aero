// src/cypher.ts
import crypto from "crypto";
function encryptValue(value, secretKey, algorithm) {
  const initVector = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(algorithm, secretKey, initVector);
  let encryptedData = cipher.update(value, "utf-8", "hex");
  encryptedData += cipher.final("hex");
  return `${initVector.toString("hex")}:${encryptedData}`;
}
function decryptValue(value, secretKey, algorithm) {
  if (value?.includes(":")) {
    const [initVector, encryptedData] = value.split(":");
    const decipher = crypto.createDecipheriv(algorithm, secretKey, Buffer.from(initVector, "hex"));
    let decryptedData = decipher.update(encryptedData, "hex", "utf-8");
    decryptedData += decipher.final("utf8");
    return decryptedData;
  }
  return value || "";
}
var cypher = (secret) => {
  const key = crypto.createHash("sha256").update(String(secret)).digest("base64").substring(0, 32);
  const algorithm = "aes-256-cbc";
  const encrypt = (value) => encryptValue(value, key, algorithm);
  const decrypt = (value) => decryptValue(value, key, algorithm);
  return {
    encrypt,
    decrypt,
    decryptMap: (map) => {
      let result = {};
      Object.keys(map).forEach((key2) => {
        result = {
          ...result,
          [key2]: decrypt(map[key2])
        };
      });
      return result;
    }
  };
};

// src/adapters/filesystem.server.ts
import fs from "fs/promises";
var createFilesystemAdapter = (filename) => {
  return {
    config: async (withSecrets) => {
      const data = await fs.readFile(filename, { encoding: "utf8" });
      const unfilteredSecrets = JSON.parse(data);
      if (withSecrets) {
        return unfilteredSecrets;
      }
      return {
        ...unfilteredSecrets,
        configuration: {
          ...unfilteredSecrets.configuration,
          CRYSTALLIZE_ACCESS_TOKEN_ID: "",
          CRYSTALLIZE_ACCESS_TOKEN_SECRET: ""
        }
      };
    }
  };
};

// src/adapters/memory.server.ts
var createMemoryAdapter = (config) => {
  return {
    config: async (withSecrets) => {
      if (withSecrets) {
        return config;
      }
      return {
        ...config,
        configuration: {
          ...config.configuration,
          CRYSTALLIZE_ACCESS_TOKEN_ID: "",
          CRYSTALLIZE_ACCESS_TOKEN_SECRET: ""
        }
      };
    }
  };
};

// src/adapters/superfast.server.ts
import { createClient } from "@crystallize/js-api-client";
import { jsonToGraphQLQuery } from "json-to-graphql-query";
var getExpiry = (ttl) => Math.floor(Date.now() / 1e3) + ttl;
var createSuperFastAdapter = (hostname, credentials, storageClient, ttl) => {
  const memoryCache = {};
  const { decrypt, decryptMap } = cypher(process.env.ENCRYPTED_PARAMS_SECRET);
  async function config(withSecrets = false) {
    const domainkey = hostname.split(".")[0];
    if (memoryCache[domainkey]) {
      if (memoryCache[domainkey].expiresAt > Date.now() / 1e3) {
        return memoryCache[domainkey].value;
      }
    }
    const hit = await storageClient.get(domainkey);
    let config2 = void 0;
    if (!hit) {
      config2 = await fetchSuperFastConfig(`/tenants/${domainkey}`, credentials);
      await storageClient.set(domainkey, JSON.stringify(config2), ttl);
    } else {
      config2 = JSON.parse(hit);
    }
    if (config2 !== void 0) {
      memoryCache[domainkey] = {
        expiresAt: getExpiry(ttl),
        value: config2
      };
      if (withSecrets) {
        config2.configuration = decryptMap(config2.configuration);
      } else {
        config2.configuration = {
          ...config2.configuration,
          STRIPE_PUBLIC_KEY: decrypt(config2.configuration.STRIPE_PUBLIC_KEY),
          RAZORPAY_ID: decrypt(config2.configuration.RAZORPAY_ID),
          ADYEN_ENV: decrypt(config2.configuration.ADYEN_ENV),
          ADYEN_MERCHANT_ACCOUNT: decrypt(config2.configuration.ADYEN_MERCHANT_ACCOUNT),
          ADYEN_CLIENT_KEY: decrypt(config2.configuration.ADYEN_CLIENT_KEY)
        };
      }
      return config2;
    }
    throw new Error("Impossible to fetch SuperFast config");
  }
  return { config };
};
var superFastTenantQueryConfig = {
  id: true,
  name: true,
  path: true,
  components: {
    id: true,
    content: {
      __typename: true,
      __on: [
        {
          __typeName: "SingleLineContent",
          text: true
        },
        {
          __typeName: "RichTextContent",
          html: true
        },
        {
          __typeName: "SelectionContent",
          options: {
            key: true,
            value: true
          }
        },
        {
          __typeName: "BooleanContent",
          value: true
        },
        {
          __typeName: "ImageContent",
          firstImage: {
            url: true,
            key: true,
            variants: {
              key: true,
              url: true,
              width: true,
              height: true
            }
          }
        },
        {
          __typeName: "PropertiesTableContent",
          sections: {
            title: true,
            properties: {
              key: true,
              value: true
            }
          }
        }
      ]
    }
  }
};
function componentToString(component) {
  switch (component?.content?.__typename) {
    case "SingleLineContent":
      return component.content.text;
    case "RichTextContent":
      return component.content.html.join("");
    case "SelectionContent":
      return component.content.options.map((option) => option.key);
    case "BooleanContent":
      return component.content.value;
    case "ImageContent":
      return component.content.firstImage;
    case "PropertiesTableContent":
      return component.content.sections.reduce((result, section) => {
        section.properties.forEach((property) => {
          result[`${section.title.toUpperCase()}_${property.key.toUpperCase()}`] = `${property.value}`;
        });
        return result;
      }, {});
    default:
      return false;
  }
}
function mapToStoreConfig(data) {
  const components = data.components.reduce((result, component) => {
    return {
      ...result,
      [component.id]: componentToString(component)
    };
  }, {});
  return {
    id: data.id,
    name: data.name,
    identifier: data.path.replace("/tenants/", ""),
    tenantIdentifier: components["tenant-identifier"],
    tenantId: components["tenant-id"] || void 0,
    language: "en",
    storefront: components.storefront,
    logo: components.logos,
    theme: components.theme[0],
    configuration: components.configuration,
    superfastVersion: components["superfast-version"],
    enabled: components["enabled"],
    paymentMethods: components["payment-methods"],
    taxIncluded: components["taxincluded"]
  };
}
async function fetchSuperFastConfigWithClient(path, client) {
  const query = {
    catalogue: {
      __args: {
        path
      },
      ...superFastTenantQueryConfig
    }
  };
  const tenant = await client.catalogueApi(jsonToGraphQLQuery({ query }));
  return mapToStoreConfig({
    id: tenant.catalogue.id,
    name: tenant.catalogue.name,
    path,
    components: tenant.catalogue.components
  });
}
async function fetchSuperFastConfig(path, credentials) {
  const client = createClient(credentials);
  return fetchSuperFastConfigWithClient(path, client);
}

// src/storefront.server.ts
import { createClient as createClient2 } from "@crystallize/js-api-client";
var createStoreFront = async (adapter, options = false, clientOptions) => {
  options = typeof options === "boolean" ? { withSecrets: options } : options;
  const withSecrets = options?.withSecrets ?? false;
  const config = await adapter.config(withSecrets);
  return {
    config,
    apiClient: createClient2(
      {
        tenantIdentifier: config.tenantIdentifier,
        tenantId: config.tenantId,
        accessTokenId: withSecrets ? config.configuration?.CRYSTALLIZE_ACCESS_TOKEN_ID || "" : "",
        accessTokenSecret: withSecrets ? config.configuration?.CRYSTALLIZE_ACCESS_TOKEN_SECRET || "" : ""
      },
      clientOptions
    )
  };
};
export {
  createFilesystemAdapter,
  createMemoryAdapter,
  createStoreFront,
  createSuperFastAdapter,
  cypher,
  decryptValue,
  encryptValue,
  fetchSuperFastConfigWithClient,
  mapToStoreConfig,
  superFastTenantQueryConfig
};
