"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleMagickLinkConfirmationRequestPayload = exports.handleMagickLinkRegisterPayload = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
async function handleMagickLinkRegisterPayload(payload, args) {
    const selector = args.userIdentifierSelector ?? ((payload) => payload.email);
    // we use a symetric key here to make it simple, but in production you should use a public/private key pair
    // which will allow you to verify the token client side too, (even if not really required it is a good idea)
    const magickToken = jsonwebtoken_1.default.sign(payload, args.jwtSecret, {
        expiresIn: '30m',
        audience: selector(payload),
        subject: 'magicklink',
        issuer: args.host,
    });
    const link = args.confirmLinkUrl.replace(':token', magickToken);
    args.mailer(args.subject, payload.email, args.from, args.buildHtml(payload, link));
    return payload;
}
exports.handleMagickLinkRegisterPayload = handleMagickLinkRegisterPayload;
async function handleMagickLinkConfirmationRequestPayload(payload, args) {
    const selector = args.userIdentifierSelector ?? ((payload) => payload.email);
    const magickToken = (args.token || '');
    const magickTokenDecoded = jsonwebtoken_1.default.verify(magickToken, args.jwtSecret);
    const jwtPayload = {
        email: magickTokenDecoded.email,
        firstname: magickTokenDecoded.firstname,
        lastname: magickTokenDecoded.lastname,
        ...(args.extraPayload ? args.extraPayload : {}),
    };
    // now we create 2 tokens, one for the frontend to indicate that we are logged in and one for the service api in the Cookie
    // the token for the frontend is NOT a prood of login
    const isSupposedToBeLoggedInOnServiceApiToken = jsonwebtoken_1.default.sign(jwtPayload, args.jwtSecret, {
        expiresIn: '1d',
        audience: selector(magickTokenDecoded),
        subject: 'isSupposedToBeLoggedInOnServiceApi',
        issuer: args.host,
    });
    const isLoggedInOnServiceApiToken = jsonwebtoken_1.default.sign(jwtPayload, args.jwtSecret, {
        expiresIn: '1d',
        audience: selector(magickTokenDecoded),
        subject: 'isLoggedInOnServiceApiToken',
        issuer: args.host,
    });
    args.setCookie('jwt', isLoggedInOnServiceApiToken);
    return args.backLinkPath.replace(':token', isSupposedToBeLoggedInOnServiceApiToken);
}
exports.handleMagickLinkConfirmationRequestPayload = handleMagickLinkConfirmationRequestPayload;
//# sourceMappingURL=handlers.js.map