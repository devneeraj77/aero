"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleVippsLoginOAuthRequestPayload = exports.handleVippsInitiateExpressCheckoutRequestPayload = exports.handleVippsPayPaymentUpdateWebhookRequestPayload = exports.handleVippsCreateCheckoutSessionRequestPayload = exports.handleVippsInitiatePaymentRequestPayload = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const client_1 = require("./client");
const fetchTokenFromOAuthCode_1 = require("./fetchTokenFromOAuthCode");
const fetchUserInfoFromOAuthToken_1 = require("./fetchUserInfoFromOAuthToken");
async function handleVippsInitiatePaymentRequestPayload(payload, args) {
    const cart = await args.fetchCart();
    const client = await (0, client_1.createClient)({
        fetchToken: true,
        origin: args.origin,
        clientId: args.clientId,
        clientSecret: args.clientSecret,
        subscriptionKey: args.subscriptionKey,
        merchantSerialNumber: args.merchantSerialNumber,
    });
    const paymentArguments = args.createIntentArguments(cart);
    const body = {
        amount: {
            currency: paymentArguments.currency,
            value: paymentArguments.amount,
        },
        paymentMethod: {
            type: paymentArguments.paymentMethod,
        },
        returnUrl: paymentArguments.returnUrl,
        reference: payload.cartId,
        userFlow: paymentArguments.userFlow,
        ...(args.otherIntentArguments ? args.otherIntentArguments : {}),
    };
    return await client.post(`/epayment/v1/payments`, body, payload.cartId);
}
exports.handleVippsInitiatePaymentRequestPayload = handleVippsInitiatePaymentRequestPayload;
async function handleVippsCreateCheckoutSessionRequestPayload(payload, args) {
    const cart = await args.fetchCart();
    const client = await (0, client_1.createClient)({
        fetchToken: false,
        origin: args.origin,
        clientId: args.clientId,
        clientSecret: args.clientSecret,
        subscriptionKey: args.subscriptionKey,
        merchantSerialNumber: args.merchantSerialNumber,
    });
    const paymentArguments = args.createCheckoutArguments(cart);
    const body = {
        merchantInfo: {
            callbackUrl: paymentArguments.callbackUrl,
            returnUrl: paymentArguments.returnUrl,
            callbackAuthorizationToken: paymentArguments.callbackAuthorizationToken,
        },
        transaction: {
            amount: {
                value: paymentArguments.amount,
                currency: paymentArguments.currency,
            },
            reference: payload.cartId,
            paymentDescription: paymentArguments.paymentDescription,
        },
        ...(args.otherCheckoutArguments ? args.otherCheckoutArguments : {}),
    };
    return await client.post(`/checkout/v3/session`, body, payload.cartId);
}
exports.handleVippsCreateCheckoutSessionRequestPayload = handleVippsCreateCheckoutSessionRequestPayload;
async function handleVippsPayPaymentUpdateWebhookRequestPayload(payload, args) {
    // we need a bit of security here in the feature when it will be a real webhook that is implemented
    // here we just call the handleEvent function directly
    return await args.handleEvent(payload);
}
exports.handleVippsPayPaymentUpdateWebhookRequestPayload = handleVippsPayPaymentUpdateWebhookRequestPayload;
async function handleVippsInitiateExpressCheckoutRequestPayload(payload, args) {
    const client = await (0, client_1.createClient)({
        fetchToken: true,
        origin: args.origin,
        clientId: args.clientId,
        clientSecret: args.clientSecret,
        subscriptionKey: args.subscriptionKey,
        merchantSerialNumber: args.merchantSerialNumber,
    });
    const cart = await args.fetchCart();
    const body = {
        customerInfo: {
            ...(payload.mobileNumber ? { mobileNumber: payload.mobileNumber } : {}),
        },
        merchantInfo: {
            merchantSerialNumber: args.merchantSerialNumber,
            callbackPrefix: args.callbackPrefix,
            fallBack: args.fallback,
            consentRemovalPrefix: args.consentRemovalPrefix,
            paymentType: 'eComm Express Payment',
            ...args.extraMerchantInfo,
        },
        transaction: {
            amount: cart.total.gross * 100,
            transactionText: cart.cart.items
                .map((item) => item.variant.name || item.product.name || item.variant.sku)
                .join(', '),
            timeStamp: new Date().toISOString(),
            orderId: payload.cartId,
        },
    };
    return await client.post(`/ecomm/v2/payments`, body, 'payload.cartId');
}
exports.handleVippsInitiateExpressCheckoutRequestPayload = handleVippsInitiateExpressCheckoutRequestPayload;
async function handleVippsLoginOAuthRequestPayload(payload, args) {
    if (payload.state !== args.expectedState) {
        throw new Error('The state does not match');
    }
    const credentials = {
        origin: args.origin,
        clientId: args.clientId,
        clientSecret: args.clientSecret,
        subscriptionKey: args.subscriptionKey,
        merchantSerialNumber: args.merchantSerialNumber,
    };
    const token = await (0, fetchTokenFromOAuthCode_1.fetchVippsTokenFromOAuthCode)(payload.code, args.redirectUri, credentials);
    const userInfos = await (0, fetchUserInfoFromOAuthToken_1.fetchVippsUserInfoFromOAuthToken)(token, credentials);
    if (args.onUserInfos) {
        await args.onUserInfos(userInfos);
    }
    const jwtPayload = {
        email: userInfos.email,
        firstname: userInfos.given_name ?? '',
        lastname: userInfos.family_name ?? '',
    };
    // now we create 2 tokens, one for the frontend to indicate that we are logged in and one for the service api in the Cookie
    // the token for the frontend is NOT a prood of login
    const isSupposedToBeLoggedInOnServiceApiToken = jsonwebtoken_1.default.sign(jwtPayload, args.jwtSecret, {
        expiresIn: '1d',
        audience: userInfos.email,
        subject: 'isSupposedToBeLoggedInOnServiceApi',
        issuer: `${args.host} via Vipps Login`,
    });
    const isLoggedInOnServiceApiToken = jsonwebtoken_1.default.sign(jwtPayload, args.jwtSecret, {
        expiresIn: '1d',
        audience: userInfos.email,
        subject: 'isLoggedInOnServiceApiToken',
        issuer: `${args.host} via Vipps Login`,
    });
    args.setCookie('jwt', isLoggedInOnServiceApiToken);
    return args.backLinkPath.replace(':token', isSupposedToBeLoggedInOnServiceApiToken);
}
exports.handleVippsLoginOAuthRequestPayload = handleVippsLoginOAuthRequestPayload;
//# sourceMappingURL=handlers.js.map